Цель:
У класса есть только один экземпляр, и он предоставляет к нему глобальную точку доступа. Существенно то, что можно пользоваться именно экземпляром класса, так как при этом во многих случаях становится доступной более широкая функциональность. Например, к описанным компонентам класса можно обращаться через интерфейс, если такая возможность поддерживается языком.

Глобальный «одинокий» объект — именно объект, а не набор процедур, не привязанных ни к какому объекту — бывает нужен:

если используется существующая объектно-ориентированная библиотека;
если есть шансы, что один объект когда-нибудь превратится в несколько;
если интерфейс объекта (например, игрового мира) слишком сложен и не стоит засорять основное пространство имён большим количеством функций;
если, в зависимости от каких-нибудь условий и настроек, создаётся один из нескольких объектов. Например, в зависимости от того, ведётся лог или нет, создаётся или настоящий объект, пишущий в файл, или «заглушка», ничего не делающая.
Такие объекты можно создавать и при инициализации программы. Это может приводить к следующим трудностям:

Если объект нужен уже при инициализации, он может быть затребован раньше, чем будет создан.
Бывает, что объект нужен не всегда. В таком случае его создание можно пропустить.


Плюсы:
контролируемый доступ к единственному экземпляру.

Минусы:
глобальные объекты могут быть вредны для объектного программирования, в некоторых случаях приводят к созданию немасштабируемого проекта;
усложняет написание модульных тестов и следование TDD.

	
Классический (и наиболее изящный) метод объявления синглтона на C++ — синглтон Майерса. Пример:

class Singleton
{
  public:
    static Singleton& Instance()
    {
        // согласно стандарту, этот код ленивый и потокобезопасный
        static Singleton s;
        return s;
    }

  private:
    Singleton() { ... }  // конструктор недоступен
    ~Singleton() { ... } // и деструктор

    // необходимо также запретить копирование
    Singleton(Singleton const&); // реализация не нужна
    Singleton& operator= (Singleton const&);  // и тут
};
Начиная с C++11, правильнее писать так:

Singleton(Singleton const&) = delete;
Singleton& operator= (Singleton const&) = delete;
Теперь по пунктам:

Оператор присваивания не нужен. Поскольку он во многих случаях создаётся компилятором «за вашей спиной», нужно задекларировать его приватным, чтобы им никто не мог воспользоваться. В C++11 вы можете прямо убрать его при помощи конструкции «= delete».
То же для конструктора копирования.
В операторах сравнения нет нужды, так как всё равно есть лишь один экземпляр. Поскольку автоматически операторы сравнения не создаются, вам не нужно ни о чём беспокоиться.
Использовать синглтон, создавая его явно, нельзя: ведь если вы смогли объявить один экземпляр, то сможете объявить сколько угодно! Поэтому варианты «ручного» создания мы исключили, сделав конструктор приватным. Получить ссылку на синглтон для работы с ним можно только так:
Singleton& instance = Singleton::Instance();

